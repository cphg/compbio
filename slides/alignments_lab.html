---
layout: aakrosh_markdown
title: "Sequence alignments"
tags: slides 
---

## {{ page.title }}
![dna](images/alignments/title_slide.png) <!-- .element height="80%" width="80%" -->            
              
---

## Algorithmic complexity

Measure of how long an algorithm would take to complete given an input of size $n$.

![growth](images/alignments/growth.pdf) <!-- .element height="50%" width="50%" -->

Note: You can talk about space complexity and/or time complexity. You assume that the underlying factor affecting your program's performance and efficiency is the hardware, OS, and CPU you use. There are also ways of talking about complexity in terms of the average case, best case (though that is never what you should concern yourself with), worst case.

---

## Algorithmic complexity

```python
def is_even_or_odd (n):
    print("Even") if n%2 == 0 else print("Odd")
```

Note: O(1)

---

## Algorithmic complexity


```python
def calcFactorial (n):
  factorial = 1
  for i in range(2,n+1):
    factorial = factorial * i
  return factorial
```

Note: O(n)

---

## Algorithmic complexity

```python
# Binary search, returns index of x in arr if present, else -1
def binary_search(arr, low, high, x):
    if high >= low:
        mid = (high + low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search(arr, low, mid - 1, x)
        else:
            return binary_search(arr, mid + 1, high, x)
    else:
        return -1

# Function call
result = binary_search(arr, 0, len(arr)-1, x)
```

Note: O(log n)

---

## Algorithmic complexity

```python
def fibonacci(n):
  if n==1 or n==0:
    return 1
  return fibonacci(n-1) + fibonacci(n-2)
```

![F7](images/alignments/f7.png) <!-- .element: class="fragment" data-fragment-index="1" -->

---

## Time Complexity

<section>
<small>
\[\begin{aligned}
T(n) &amp; = T(n-1) + T(n-2) + 1 \\
&amp; < 2 \times T(n-1) + 1 \\
&amp; < 4 \times T(n-2) + 3 \\
&amp;  \ldots \\
&amp; < 2^k \times T(n-k) + (2^k - 1) \\
&amp; = \ldots \\
&amp; < 2^n \times T(0) + (2^n - 1) \\
&amp; = 2^n + 2^n - 1 \\
&amp; = O(2^n)
\end{aligned} \]
</small>
</section>

Note: In reality the time complexity of this recurrence is O(1.618^n)


---

## Computing Fibonacci numbers

```python
def fibonacci(n):
  fib_table = {}
  fib_table[1] = 1
  fib_table[2] = 1
  for i in range(3,n+1):
    fib_table[i] = fib_table[i-1] + fib_table[i-2]
  return fib_table[n]
```

![F7](images/alignments/f7_memoize.png) <!-- .element height="60%" width="60%" class="fragment" data-fragment-index="1" -->

Note: What is the time complexity here? O(n). This is a dynamic programming algorithm: basically recursion, but with intentional evaluation order, usually filling out a table systematically.

---

## Dynamic Programming

* https://github.com/cphg/sequence_alignment
* Implement local alignment of two sequences that can use affine gap penalties
* Skeleton code is provided in python 
* Simple test cases are also provided 
* Clone the repo, implement the `smith_waterman` function in `align_sequences.py`
* You can test your work by running `python3 testdriver`

---

## SAM format

```shell
samtools flagstats 1474_TNMatch_T.sorted.bam
```

```text
103179474 + 0 in total (QC-passed reads + QC-failed reads)
103179474 + 0 primary
0 + 0 secondary
0 + 0 supplementary
30618344 + 0 duplicates
30618344 + 0 primary duplicates
91410312 + 0 mapped (88.59% : N/A)
91410312 + 0 primary mapped (88.59% : N/A)
103179474 + 0 paired in sequencing
51589737 + 0 read1
51589737 + 0 read2
90175864 + 0 properly paired (87.40% : N/A)
90287592 + 0 with itself and mate mapped
1122720 + 0 singletons (1.09% : N/A)
4776 + 0 with mate mapped to a different chr
4536 + 0 with mate mapped to a different chr (mapQ>=5)

```

---

## BLAST output

![blast](images/alignments/blast_output.png)

Note: Indicates the number of hits or alignments that are expected to be seen by random chance with the same score or better. The lower the E-value, the more significant the alignment (the closer to 0, the better). 

---

## More on short-read alignment algorithms

https://cphg.github.io/compgen/slides/short_read.html

---

## Dynamic Programming

* https://github.com/cphg/sequence_alignment
* Implement local alignment of two sequences that can use affine gap penalties
* Skeleton code is provided in python
* Simple test cases are also provided
* Clone the repo, implement the `smith_waterman` function in `align_sequences.py`
* You can test your work by running `python3 testdriver`

---
